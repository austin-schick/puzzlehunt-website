<!DOCTYPE html>
<html>
<head>
  <title>15-112: Fundamentals of Programming</title>
  <link rel="stylesheet" type="text/css" href="../css/reset.css">
  <link rel="stylesheet" type="text/css" href="../css/bootstrap.min.css">
  <link rel="stylesheet" type="text/css" href="../css/112.css">
  <link rel="stylesheet" type="text/css" href="../css/112-highlight-style.css">
  <script src="../js/jquery-2.1.4.min.js"></script>
  <script src="../js/highlight.pack.js"></script>
  <script src="../js/bootstrap.min.js"></script>
  <script id="112-script" src="../js/112.js"></script>
  <base target="_self">
</head>
<body>

<div class="navbar">
15-112 <br> Spring 18
<br><br><a target="_self" href="../index.html">Home</a>
<br><br><a target="_self" href="../syllabus.html">Syllabus</a>
<br><br><a target="_self" href="../schedule.html">Schedule</a>
<br><br><a target="_self" href="../gallery.html">Gallery</a>
<br><br><a target="_self" href="../staff.html">Staff</a>
<br><br><a target="_self" href="../piazza.html">Piazza</a>
<br><br><a target="_self" href="../autolab.html">Autolab</a>
<br><br><a target="_blank" href="../oh-queue.html">OH Queue</a>
</div>

<div class="content">
<h1>
CMU 15-112: Fundamentals of Programming and Computer Science<br>
Class Notes: Recursion Part 1<br>
</h1>
<hr>

<ol>
<li><b><a href="#gettingStarted">Getting Started</a></b></li>
<li><b><a href="#popularRecursion">Popular Recursion</a></b></li>
<li><b><a href="#generalForm">General Recursive Form</a></b></li>
<li><b><a href="#recursiveMath">Recursive Math</a></b>
<li><b><a href="#basicExamples">Basic Examples</a></b>
<ol>
<li><b><a href="#rangeSum">rangeSum</a></b></li>
<li><b><a href="#listSum">listSum</a></b></li>
<li><b><a href="#power">power</a></b></li>
<li><b><a href="#interleave">interleave</a></b></li>
</ol></li>
<li><b><a href="#divideAndConquerExamples">Divide-And-Conquer Examples</a></b>
<ol>
<li><b><a href="#rangeSumByHalves">rangeSum</a></b></li>
<li><b><a href="#listSumByHalves">listSum</a></b></li>
<li><b><a href="#powerByHalves">power</a></b></li>
<li><b><a href="#interleaveByHalves">interleave</a></b></li>
</ol></li>
<li><b><a href="#multipleCases">Examples with Multiple Base or Recursive Cases</a></b>
<ol>
<li><b><a href="#powerWithNegExp">power with negative exponents</a></b></li>
<li><b><a href="#interleaveDiffLens">interleave with different-length lists</a></b></li>
</ol></li>
<li><b><a href="#multipleRecursiveCalls">Examples with Multiple Recursive Calls</a></b>
<ol>
<li><b><a href="#fibonacci">fibonacci</a></b></li>
<li><b><a href="#hanoi">towersOfHanoi</a></b></li>
</ol></li>
<li><b><a href="#iterVsRecExamples">Examples Comparing Iteration and Recursion</a></b>
<ol>
<li><b><a href="#factorial">factorial</a></b></li>
<li><b><a href="#reverse">reverse</a></b></li>
<li><b><a href="#gcd">gcd</a></b></li>
</ol></li>
<li><b><a href="#iterationVsRecursion">Iteration vs Recursion Summary</a></b></li>
</ol>
<hr>

<ol>

<li><a name="gettingStarted"></a><b>Getting Started</b></a><br>
See
<a target="_blank" href="notes-recursion-part0.html">these notes</a> with some recursion examples to get started on the topic.

</li><br><li><a name="popularRecursion"></a><b>Popular Recursion</b></a>
<span class="play-video"
      data-src="https://www.youtube.com/embed/L3_TP7XE_9Q"></span><br>
<ol>
<li><b>"Recursion": </b>See "Recursion"<b>.</b></li>
<li><b>Google search: </b>
<a target="_blank" href="http://www.google.com/search?q=recursion">Recursion</a></li>
<li><b>Recursion comic:  </b>
<a target="_blank" href="http://xkcd.com/244/">http://xkcd.com/244/</a></li>
<li><b>Droste Effect:  </b>See
<a target="_blank" href="http://en.wikipedia.org/wiki/Droste_effect">the 
Wikipedia page</a> and
<a target="_blank" href="http://www.google.com/search?q=droste+effect&tbm=isch">
this Google image search</a></li>
<li><b>Fractals: </b>See
<a target="_blank" href="http://en.wikipedia.org/wiki/Fractal">the Wikipedia 
page</a> and
<a target="_blank" href="http://www.google.com/search?q=fractal&tbm=isch">this 
Google image search</a> and
<a target="_blank" href="http://youtu.be/G_GBwuYuOOs">this infinitely-zooming 
video</a></li>
<li><b>The Chicken and Egg Problem</b> (mutual recursion)</li>
<li><b>Sourdough Recipe:</b> First, start with some sourdough, then...</li>
<li><b>Books:</b> <a target="_blank" href="http://amzn.com/0465026567">Godel, 
Escher, Bach</a>; <a target="_blank" href="http://amzn.com/0465045669">
Metamagical Themas;</a></li>
<li><b>Wikipedia page on Recursion:</b>
See <a target="_blank" href="https://en.wikipedia.org/wiki/Recursion_(computer_science)"
>here</a>.</li>
</ol></li>

</li><br><li><a name="generalForm"></a><b>General Recursive Form</b></a>
<span class="play-video"
      data-src="https://www.youtube.com/embed/IR3QBg8o--I"></span><br>
<div class="python-code no-viz no-run no-copy">
def recursiveFunction():
    if (this is the base case):
        # no recursion allowed here!
        do something non-recursive
    else:
        # this is the recursive case!
        do something recursive
</div>

</li><br><li><a name="recursiveMath"></a><b>Recursive Math</b></a>
<span class="play-video"
      data-src="https://www.youtube.com/embed/8HwMpgolTHA"></span><br>
<div class="python-code no-viz no-run">
# A few example recursive functions.
# Can you figure out what each one does, in general?

import math

def f1(x):
    if (x == 0): return 0
    else: return 1 + f1(x-1)

def f2(x):
    if (x == 0): return 40
    else: return 1 + f2(x-1)

def f3(x):
    if (x == 0): return 0
    else: return 2 + f3(x-1)

def f4(x):
    if (x == 0): return 40
    else: return 2 + f4(x-1)

def f5(x):
    if (x == 0): return 0
    else: return x + f5(x-1) # why does this work?

def f6(x):
    if (x == 0): return 0
    else: return 2*x-1 + f6(x-1) # why does this work?

def f7(x):
    if (x == 0): return 1
    else: return 2*f7(x-1)

def f8(x):
    if (x < 2): return 0
    else: return 1 + f8(x//2)

def f9(x):
    if (x < 2): return 1
    else: return f9(x-1) + f9(x-2)

def f10(x):
    if (x == 0): return 1
    else: return x*f10(x-1)

def f11(x, y):
    if (y < 0): return -f11(x, -y)
    elif (y == 0): return 0
    else: return x + f11(x, y-1)

def f12(x,y):
    if ((x < 0) and (y < 0)): return f12(-x,-y)
    elif ((x == 0) or (y == 0)): return 0
    else: return x+y-1 + f12(x-1, y-1)  # why does this work?

def f13(L):
    assert(type(L) == list)
    if (len(L) < 2): return [ ]
    else: return f13(L[2:]) + [L[1]]

def go():
    while True:
        n = input("Enter function # (1-13, or 0 to quit): ")
        if (n == "0"): break
        elif (n == "11"): print("f11(5, 7) ==", f11(5, 7))
        elif (n == "12"): print("f12(5, 7) ==", f12(5, 7))
        elif (n == "13"): print("f13(list(range(20))) ==", f13(list(range(20))))
        else:
            f = globals()["f"+n]
            print("f"+n+": ", [f(x) for x in range(10)])
        print()

go()
</div>

</li><br><li><a name="basicExamples"></a><b>Basic Examples</b></a>
<span class="play-video"
      data-src="https://www.youtube.com/embed/BGBtEB3q30M"></span><br>
<ol>
<li><a name="rangeSum"><b>rangeSum</b></a>
<div class="python-code">
def rangeSum(lo, hi):
    if (lo > hi):
        return 0
    else:
        return lo + rangeSum(lo+1, hi)

print(rangeSum(10,15)) # 75
</div>

</li><br><li><a name="listSum"><b>listSum</b></a>
<div class="python-code">
def listSum(L):
    if (len(L) == 0):
        return 0
    else:
        return L[0] + listSum(L[1:])

print(listSum([2,3,5,7,11])) # 28
</div>

</li><br><li><a name="power"><b>power</b></a>
<div class="python-code">
def power(base, expt):
    # assume expt is non-negative integer
    if (expt == 0):
        return 1
    else:
        return base * power(base, expt-1)

print(power(2,5)) # 32
</div>

</li><br><li><a name="interleave"><b>interleave</b></a>
<div class="python-code">
def interleave(list1, list2):
    # assume list1 and list2 are same-length lists
    if (list1 == []):
        return []
    else:
        return [list1[0] , list2[0]] + interleave(list1[1:], list2[1:])

print(interleave([1,2,3],[4,5,6]))  # [1,4,2,5,3,6]
</div>
</li>
</ol>

</li><br><li><a name="divideAndConquerExamples"></a><b>Divide-And-Conquer Examples</b></a>
<span class="play-video"
      data-src="https://www.youtube.com/embed/Q5vcAoLi9Qk"></span><br>
<ol>
<li><a name="rangeSumByHalves"><b>rangeSum</b></a>
<div class="python-code">
def rangeSum(lo, hi):
    if (lo == hi):
        return lo
    else:
        mid = (lo + hi)//2
        return rangeSum(lo, mid) + rangeSum(mid+1, hi)

print(rangeSum(10,15)) # 75
</div>

</li><br><li><a name="listSumByHalves"><b>listSum</b></a>
<div class="python-code">
def listSum(L):
    if (len(L) == 0):
        return 0
    elif (len(L) == 1):
        return L[0]
    else:
        mid = len(L)//2
        return listSum(L[:mid]) + listSum(L[mid:])

print(listSum([2,3,5,7,11])) # 28
</div>

</li><br><li><a name="powerByHalves"><b>power</b></a>
<div class="python-code">
def power(base, expt):
    # assume expt is non-negative integer
    if (expt == 0):
        return 1
    elif (expt % 2 == 0):
        return power(base, expt//2)**2
    else:
        return base * power(base, expt//2)**2

print(power(2,5)) # 32
</div>

</li><br><li><a name="interleaveByHalves"><b>interleave</b></a>
<div class="python-code">
def interleave(list1, list2):
    # assume list1 and list2 are same-length lists
    if (len(list1) == 0):
        return []
    elif (len(list1) == 1):
        return [list1[0], list2[0]]
    else:
        mid = len(list1)//2
        return (interleave(list1[:mid], list2[:mid]) +
                interleave(list1[mid:], list2[mid:]))

print(interleave([1,2,3],[4,5,6]))  # [1,4,2,5,3,6]
</div>
</li>
</ol>

</li><br><li><a name="multipleCases"></a><b>Examples with Multiple Base or Recursive Cases</b></a>
<span class="play-video"
      data-src="https://www.youtube.com/embed/-NuDMydpvJQ"></span><br>
<ol>
<li><a name="powerWithNegExp"><b>power with negative exponents</b></a>
<div class="python-code">
def power(base, expt):
    # This version allows for negative exponents
    # It still assumes that expt is an integer, however.
    if (expt == 0):
        return 1
    elif (expt < 0):
        return 1.0/power(base,abs(expt))
    else:
        return base * power(base, expt-1)

print(power(2,5)) # 32
print(power(2,-5)) # 1/32 = 0.03125
</div>

</li><br><li><a name="interleaveDiffLens"><b>interleave with different-length lists</b></a>
<div class="python-code">
def interleave(list1, list2):
    # This version allows for different-length lists
    if (len(list1) == 0):
        return list2
    elif (len(list2) == 0):
        return list1
    else:
        return [list1[0] , list2[0]] + interleave(list1[1:], list2[1:])

print(interleave([1,2],[3,4,5,6])) # [1,3,2,4,5,6]
</div>
</li>
</ol>

</li><br><li><a name="multipleRecursiveCalls"></a><b>Examples with Multiple Recursive Calls</b></a>
<ol>
<li><a name="fibonacci"><b>fibonacci</b></a>
<span class="play-video"
      data-src="https://www.youtube.com/embed/PYfJm3ooTxk"></span><br>
<ol type="A">
<li><b>First attempt</b>
<div class="python-code">
# Note: as written, this function is very inefficient!
# (We need to use "memoization" to speed it up! See below for details!)
def fib(n):
    if (n < 2):
        # Base case:  fib(0) and fib(1) are both 1
        return 1
    else:
        # Recursive case: fib(n) = fib(n-1) + fib(n-2)
        return fib(n-1) + fib(n-2)

print([fib(n) for n in range(15)])
</div>

</li><br><li><b>Once again, printing call stack using recursion depth:</b>
<div class="python-code">
def fib(n, depth=0):
    print("   "*depth, "fib(", n, " )")
    if (n < 2):
        # Base case:  fib(0) and fib(1) are both 1
        return 1
    else:
        return fib(n-1, depth+1) + fib(n-2, depth+1)
fib(4)
</div>

</li><br><li><b>Even better (printing result, too):</b>
<div class="python-code">
def fib(n, depth=0):
    print("   "*depth, "fib(", n, " )")
    if (n < 2):
        result = 1
        # Base case:  fib(0) and fib(1) are both 1
        print("   "*depth, "-->", result)
        return result
    else:
        result = fib(n-1, depth+1) + fib(n-2, depth+1)
        print("   "*depth, "-->", result)
        return result
fib(4)
</div>

</li><br><li><b>Finally, not duplicating code:</b>
<div class="python-code">
def fib(n, depth=0):
    print("   "*depth, "fib(", n, " )")
    if (n < 2):
        result = 1
    else:
        result = fib(n-1, depth+1) + fib(n-2, depth+1)
    print("   "*depth, "-->", result)
    return result
fib(4)
</div>

</li>
</ol>

</li><br><li><a name="hanoi"><b>towersOfHanoi</b></a>
<span class="play-video"
      data-src="https://www.youtube.com/embed/T3U5puQq4KU"></span><br>
<ol type="A">
<li><b>First attempt (without Python):</b>
<div class="python-code no-viz no-run no-copy">
# This is the plan to solve Towers of Hanoi (based on magic!)
magically move(n-1, source, temp, target)
          move(  1, source, target, temp)
magically move(n-1, temp, target, source)
</div>

</li><br><li><b>Turn into Python (The "magic" is recursion!):</b>
<div class="python-code">
def move(n, source, target, temp):
    move(n-1, source, temp, target)
    move(  1, source, target, temp)
    move(n-1, temp, target, source)

move(2, 0, 1, 2) # Does not work -- infinite recursion
</div>

</li><br><li><b>Once again, with a base case:</b>
<div class="python-code">
def move(n, source, target, temp):
    if (n == 1):
        print((source, target), end="")
    else:
        move(n-1, source, temp, target)
        move(  1, source, target, temp)
        move(n-1, temp, target, source)

move(2, 0, 1, 2)
</div>

</li><br><li><b>Once more, with a nice wrapper:</b>
<div class="python-code">
def move(n, source, target, temp):
    if (n == 1):
        print((source, target), end="")
    else:
        move(n-1, source, temp, target)
        move(  1, source, target, temp)
        move(n-1, temp, target, source)

def hanoi(n):
    print("Solving Towers of Hanoi with n =", n)
    move(n, 0, 1, 2)
    print()

hanoi(4)
</div>

</li><br><li><b>And again, printing call stack and recursion depth:</b>
<div class="python-code">
def move(n, source, target, temp, depth=0):
    print((" " * 3 * depth), "move", n,
          "from", source, "to", target, "via", temp)
    if (n == 1):
        print((" " * 3 * depth), (source, target))
    else:
        move(n-1, source, temp, target, depth+1)
        move(  1, source, target, temp, depth+1)
        move(n-1, temp, target, source, depth+1)

def hanoi(n):
    print("Solving Towers of Hanoi with n =", n)
    move(n, 0, 1, 2)
    print()
hanoi(4)
</div>

</li><br><li><b>Iterative Towers of Hanoi (just to see it's possible):</b>
<div class="python-code">
def iterativeHanoi(n):
    def f(k): return (k%3) if (n%2==0) else (-k%3)
    return [(f(move & (move-1)),
             f((move|(move-1))+1)) for move in range(1,1 << n)]

def recursiveHanoi(n, source=0, target=1, temp=2):
    if (n == 1):
        return [(source, target)]
    else:
        return (recursiveHanoi(n-1, source, temp, target) +
                recursiveHanoi(  1, source, target, temp) +
                recursiveHanoi(n-1, temp, target, source))

def compareIterativeAndRecursiveHanoi():
    for n in range(1,10):
        assert(iterativeHanoi(n) == recursiveHanoi(n))
    print("iterative and recursive solutions match exactly in all tests!")

compareIterativeAndRecursiveHanoi()
</div>
</li>
</ol>
</li>
</ol>

</li><br><li><a name="iterVsRecExamples"><b>Examples Comparing Iteration and Recursion</b></a>
<span class="play-video"
      data-src="https://www.youtube.com/embed/4I1aCfVPm30"></span><br>
<table width="100%">
  <tbody>
    <tr>
      <td><b>Function</b></td>
      <td><center><b>&nbsp;Iterative Solution</b></center></td>
      <td><center><b>&nbsp;Recursive Solution</b></center></td>
      <td><center><b>&nbsp;Recursive Solution with Stack Trace</b></center></td>
    </tr>
    <tr>
    <td><a name="factorial"><b>factorial</b></a></td>
    <td><div class="python-code">
def factorial(n):
    factorial = 1
    for i in range(2,n+1):
        factorial *= i
    return factorial

print(factorial(5))
    </div>
    </td>
    <td><div class="python-code">
def factorial(n):
    if (n < 2):
        return 1
    else:
        return n*factorial(n-1)

print(factorial(5))
    </div>
    </td>
    <td><div class="python-code">
def factorial(n, depth=0):
    print("   "*depth, "factorial(",n,"):")
    if (n < 2):
        result = 1
    else:
        result = n*factorial(n-1,depth+1)
    print("   "*depth, "-->", result)
    return result

print(factorial(5))   
    </div>
    </td>
    </tr>

    <tr>
    <td><a name="reverse"><b>reverse</b></a></td>
    <td><div class="python-code">
def reverse(s):
    reverse = ""
    for ch in s:
        reverse = ch + reverse
    return reverse

print(reverse("abcd"))
    </div>
    </td>
    <td><div class="python-code">
def reverse(s):
    if (len(s) < 2):
        return s
    else:
        mid = len(s)//2
        return (reverse(s[mid:]) +
                reverse(s[:mid]))

print(reverse("abcd"))
    </div>
    </td>
    <td><div class="python-code">
def reverse(s, depth=0):
    print("   "*depth, "reverse(",s,"):")
    if (len(s) < 2):
        result = s
    else:
        mid = len(s)//2
        result = (reverse(s[mid:], depth+1) +
                  reverse(s[:mid], depth+1))
    print("   "*depth, "-->", result)
    return result

print(reverse("abcd"))  
    </div>
    </td>
    </tr>

    <tr>
    <td><a name="gcd"><b>gcd</b></a></td>
    <td><div class="python-code">
def gcd(x,y):
    while (y > 0):
        (x, y) = (y, x%y)
    return x

print(gcd(500, 420)) # 20
    </div>
    </td>
    <td><div class="python-code">
def gcd(x,y):
    if (y == 0):
        return x
    else:
        return gcd(y,x%y)

print(gcd(500, 420)) # 20
    </div>
    </td>
    <td><div class="python-code">
def gcd(x,y,depth=0):
    print("   "*depth, "gcd(",x, ",", y, "):")
    if (y == 0):
        result = x
    else:
        result = gcd(y, x%y, depth+1)
    print("   "*depth, "-->", result)
    return result

print(gcd(500, 420)) # 20  
    </div>
    </td>
    </tr>

  </tbody>
</table>

</li><br><li><a name="iterationVsRecursion"></a><b>Iteration vs Recursion Summary</b></a>
<span class="play-video"
      data-src="https://www.youtube.com/embed/S9dD8UhYKoY"></span><br>
<table>
  <tbody>
    <tr>
      <td></td>
      <td><center><b>Recursion</b></center></td>
      <td><center><b>Iteration</b></center></td>
    </tr>
    <tr>
      <td><b>Elegance</b></td>
      <td><center><span class="glyphicon glyphicon-ok"></span></center></td>
      <td><center><span class="glyphicon glyphicon-remove"></span></center></td>
    </tr>
    <tr>
      <td><b>Performance</b></td>
      <td><center><span class="glyphicon glyphicon-remove"></span></center></td>
      <td><center><span class="glyphicon glyphicon-ok"></span></center></td>
    </tr>
    <tr>
      <td><b>Debuggability</b></td>
      <td><center><span class="glyphicon glyphicon-remove"></span></center></td>
      <td><center><span class="glyphicon glyphicon-ok"></span></center></td>
    </tr>
  </tbody>
</table>
<br>
Note:  These are general guidelines.   For example, it is possible to use recursion with high performance, and it is certainly possible to use (or abuse) iteration with very low performance.
<br><br>
Conclusion (for now):  Use iteration when practicable.  Use recursion when required (for "naturally recursive problems").
 
</ol>
<hr>
</div>
</body>
</html>
